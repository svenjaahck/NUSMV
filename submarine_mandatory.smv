
/--
Group 6: Noah Rahimzadagan, Philipe GranhÃ¤ll, Svenja Haeckel
--/

MODULE submarine
  VAR
    hatch: { open, closed }; -- submarine hatch
    lock:  { unlocked, locked }; -- hatch lock
    direction: { up, flat, down }; -- direction (controller by MAIN)
    depth: 0..10;  -- depth; depth always stays in a interval between 0 and 10

DEFINE
  submerged := depth > 0;

ASSIGN
  init (hatch) := (submerged) ? closed : { open, closed };
  -- the hatch is closed when restarting the controller in a submerged state
  
  init (lock) := case -- the lock is engaged when submerged but not when the hatch is open
    submerged : locked;
    hatch = open: unlocked;
    hatch = closed : { locked, unlocked };
  esac;

  next (hatch) := (hatch = closed & lock = locked) ? closed : { open, closed };
  -- the hatch stays closed when locked and closes non-deterministically when it is open

  next (depth) := case -- next depth depending on direction
	direction = flat : depth; -- if the direction is flat, the depth remains the same
	direction = up & depth > 0: depth - 1; -- if the direction is up, the depth is reduced by one
	direction = down & depth < 10: depth + 1; -- if the direction is down, the depth is increasing by one
	TRUE: depth;
    -- TODO: define next state
	esac;

MODULE main
VAR
  sub: submarine; -- physical sensor data and engine (direction) control
  target_reached: boolean; -- denote if target is reached
  emergency: boolean; -- emergency (yes if TRUE)
  target_depth: 1..10;  -- target depth (> 0)

ASSIGN
  next (target_depth) := target_depth; -- target does not change

  init (target_reached) := sub.depth = target_depth; -- target has to be reached first
  next (target_reached) := target_reached | (sub.depth = target_depth);

  next (sub.lock) := case -- control lock
    next(sub.hatch) = open: unlocked; -- cannot lock an open hatch
	sub.depth > 0: locked; -- lock hatch if depth is greater than zero
	sub.depth = 0 & next(sub.direction) = down: locked; -- lock if a dive is about to be initiated(going from depth = 0 to depth = 1)
    -- TODO: ensure hatch is locked when needed
    TRUE: { locked, unlocked };
  esac;

  next (emergency) := case -- emergency occurs non-deterministically
    sub.depth = 0 & next(sub.depth) = 0: { TRUE, FALSE }; -- possibility to resolve when on surface
    emergency : TRUE;
    TRUE: { TRUE, FALSE };
  esac;

  init (sub.direction) := flat; -- flat when controller restarts

  next (sub.direction) := case
	 target_reached : flat;
	 !target_reached & !emergency & target_depth > sub.depth : down;
	 emergency & sub.depth > 0: up;
	 emergency & sub.depth = 0: flat;
	 !emergency & sub.depth = 0 & sub.hatch = closed: { flat, down };
	 sub.depth = 0: {flat, down};
	 sub.depth = 10: {flat, up};
    TRUE: { up, flat, down };
  esac;
  
  FAIRNESS
  sub.depth = 0;
  /--
  FAIRNESS
  sub.direction = up;
  --/
  
  
  
 
-- Properties --

  LTLSPEC
  G(next(sub.depth) = sub.depth - 1|next(sub.depth) = sub.depth |next(sub.depth) = sub.depth + 1); --safety -- 1. The depth never changes by more than one unit per step.--true
  LTLSPEC
  G(sub.depth >= 0 & sub.depth <= 10);--safety -- 2. The depth always stays within interval 0..10.--true
  LTLSPEC
  G(F next(sub.depth) = 0);--liveness -- 3. The submarine always has the capability to get back to the surface.--Fairness property?--true
  CTLSPEC
  AG(!emergency -> AF(emergency | target_reached));--liveness -- 4. The submarine has the capability to reach target_depth , unless there is an emergency.--true
  LTLSPEC
  G((emergency | sub.hatch = open) -> next(sub.direction) != down);--safety -- 5. In an emergency or when the hatch is open, the submarine does not go down.--false
  /--
  LTLSPEC
  G(sub.hatch = open -> !(next(sub.depth) = sub.depth - 1));--safety -- 5. In an emergency or when the hatch is open, the submarine does not go down.
  LTLSPEC
  G(emergency U sub.depth = 0);--safety -- 6. An emergency can only be resolved by resurfacing (so emergency cannot go back to false once set unless depth=0.
  LTLSPEC
  G(sub.depth > 0 -> sub.hatch = closed);--safety -- 7. The hatch is always closed when submerged, i.e., depth>0.
  LTLSPEC
  G !(sub.lock = locked -> sub.hatch = open);--safety -- 8. The hatch can only open when it is unlocked.
  LTLSPEC  
  G(sub.submerged -> sub.lock = locked);--safety -- 9. The hatch lock must be locked whenever depth>0.
  LTLSPEC
  G!(sub.hatch = open -> sub.lock = locked);-- safety --10. The lock can only be in state locked when the hatch is closed.
  --/


/--
Example error trace for a mutated model 
before:
next (depth) := case -- next depth depending on direction
	depth = 0 & direction = up: depth; -- ensuring the depth can not go more up after surface is reached 
	direction = flat : depth; -- if the direction is flat, the depth remains the same
	direction = up : depth - 1; -- if the direction is up, the depth is reduced by one
	direction = down : depth + 1; -- if the direction is down, the depth is increasing by one
	TRUE: depth;
	esac;
--error message
file submarine_mandatory.smv: line 36: cannot assign value 11 to variable sub.depth

the direction should be flat at 10 and the depth should remain to not reach number 11 as a value
--
after:
next (depth) := case -- next depth depending on direction
	depth = 10 & direction = down : depth ; -- ensuring the depth remains the same when the maximum depth is reached
	depth = 0 & direction = up: depth; -- ensuring the depth can not go more up after surface is reached 
	direction = flat : depth; -- if the direction is flat, the depth remains the same
	direction = up : depth - 1; -- if the direction is up, the depth is reduced by one
	direction = down : depth + 1; -- if the direction is down, the depth is increasing by one
	TRUE: depth;
--/

/--
Example error trace for a mutated property
-- specification  G ((next(sub.depth) = sub.depth - 1 | next(sub.depth) = sub.depth) | next(sub.depth) = sub.depth + 1)  is true
-- specification  G (sub.depth >= 0 & sub.depth <= 10)  is true
-- specification  G ( F next(sub.depth) = 0)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -- Loop starts here
  -> State: 1.1 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    sub.depth = 1
    target_reached = FALSE
    emergency = FALSE
    target_depth = 2
    sub.submerged = TRUE
  -> State: 1.2 <-
-- specification  G (emergency -> !(next(sub.depth) = sub.depth - 1))  is true
-- specification  G (emergency U sub.depth = 0)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -- Loop starts here
  -> State: 2.1 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    sub.depth = 1
    target_reached = FALSE
    emergency = TRUE
    target_depth = 2
    sub.submerged = TRUE
  -> State: 2.2 <-
-- specification  G (( F next(sub.depth) = target_depth) U emergency)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -- Loop starts here
  -> State: 3.1 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    sub.depth = 1
    target_reached = FALSE
    emergency = FALSE
    target_depth = 2
    sub.submerged = TRUE
  -> State: 3.2 <-
-- specification  G (sub.hatch = open -> !(next(sub.depth) = sub.depth - 1))  is true
-- specification  G (sub.depth > 0 -> sub.hatch = closed)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -> State: 4.1 <-
    sub.hatch = open
    sub.lock = unlocked
    sub.direction = flat
    sub.depth = 0
    target_reached = FALSE
    emergency = FALSE
    target_depth = 1
    sub.submerged = FALSE
  -> State: 4.2 <-
    sub.direction = down
    sub.depth = 1
    sub.submerged = TRUE
  -- Loop starts here
  -> State: 4.3 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    target_reached = TRUE
  -> State: 4.4 <-
-- specification  G !(sub.lock = locked -> sub.hatch = open)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -> State: 5.1 <-
    sub.hatch = open
    sub.lock = unlocked
    sub.direction = flat
    sub.depth = 0
    target_reached = FALSE
    emergency = FALSE
    target_depth = 1
    sub.submerged = FALSE
  -> State: 5.2 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = down
    sub.depth = 1
    sub.submerged = TRUE
  -- Loop starts here
  -> State: 5.3 <-
    sub.direction = flat
    target_reached = TRUE
  -> State: 5.4 <-
-- specification  G (sub.submerged -> sub.lock = locked)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -> State: 6.1 <-
    sub.hatch = open
    sub.lock = unlocked
    sub.direction = flat
    sub.depth = 0
    target_reached = FALSE
    emergency = FALSE
    target_depth = 1
    sub.submerged = FALSE
  -> State: 6.2 <-
    sub.direction = down
    sub.depth = 1
    sub.submerged = TRUE
  -- Loop starts here
  -> State: 6.3 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    target_reached = TRUE
  -> State: 6.4 <-
-- specification  G !(sub.hatch = open -> sub.lock = locked)  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -- Loop starts here
  -> State: 7.1 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    sub.depth = 1
    target_reached = FALSE
    emergency = FALSE
    target_depth = 2
    sub.submerged = TRUE
  -> State: 7.2 <-

--/
/--
simulate -i -k 5 simulate 5 states and document the outcome
--/

/--
missing feature in the model
--/

/--
property for missing feature
--/









