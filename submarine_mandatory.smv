
/--
Group 6: Noah Rahimzadagan, Philipe GranhÃ¤ll, Svenja Haeckel
--/

MODULE submarine
  VAR
    hatch: { open, closed }; -- submarine hatch
    lock:  { unlocked, locked }; -- hatch lock
    direction: { up, flat, down }; -- direction (controller by MAIN)
    depth: 0..10;  -- depth; depth always stays in a interval between 0 and 10

DEFINE
  submerged := depth > 0;

ASSIGN
  init (hatch) := (submerged) ? closed : { open, closed };
  -- the hatch is closed when restarting the controller in a submerged state
  
  init (lock) := case -- the lock is engaged when submerged but not when the hatch is open
    submerged : locked;
    hatch = open: unlocked;
    hatch = closed : { locked, unlocked };
  esac;

  next (hatch) := (hatch = closed & lock = locked) ? closed : { open, closed };
  -- the hatch stays closed when locked and closes non-deterministically when it is open

  next (depth) := case -- next depth depending on direction
	direction = flat : depth; -- if the direction is flat, the depth remains the same
	direction = up & depth > 0: depth - 1; -- if the direction is up, the depth is reduced by one
	direction = down & depth < 10: depth + 1; -- if the direction is down, the depth is increasing by one
	TRUE: depth;
    -- TODO: define next state
	esac;

MODULE main
VAR
  sub: submarine; -- physical sensor data and engine (direction) control
  target_reached: boolean; -- denote if target is reached
  emergency: boolean; -- emergency (yes if TRUE)
  target_depth: 1..10;  -- target depth (> 0)

ASSIGN
  next (target_depth) := target_depth; -- target does not change

  init (target_reached) := sub.depth = target_depth; -- target has to be reached first
  next (target_reached) := target_reached | (sub.depth = target_depth);

  next (sub.lock) := case -- control lock
    next(sub.hatch) = open: unlocked; -- cannot lock an open hatch
	sub.depth > 0: locked; -- lock hatch if depth is greater than zero
	sub.depth = 0 & next(sub.direction) = down: locked; -- lock if a dive is about to be initiated(going from depth = 0 to depth = 1)
    -- TODO: ensure hatch is locked when needed
    TRUE: { locked, unlocked };
  esac;

  next (emergency) := case -- emergency occurs non-deterministically
    sub.depth = 0 & next(sub.depth) = 0: { TRUE, FALSE }; -- possibility to resolve when on surface
    emergency : TRUE;
    TRUE: { TRUE, FALSE };
  esac;

  init (sub.direction) := flat; -- flat when controller restarts

  next (sub.direction) := case
	 target_reached : flat;
	 !target_reached & !emergency & target_depth > sub.depth : down;
	 emergency & sub.depth > 0: up;
	 emergency & sub.depth = 0: flat;
	 !emergency & sub.depth = 0 & sub.hatch = closed: { flat, down };
	 sub.depth = 0: {flat, down};
	 sub.depth = 10: {flat, up};
    TRUE: { up, flat, down };
  esac;
  
  FAIRNESS
  sub.depth = 0;
  /--
  FAIRNESS
  sub.direction = up;
  --/
  
  
  
 
-- Properties --

  LTLSPEC
  G(next(sub.depth) = sub.depth - 1|next(sub.depth) = sub.depth |next(sub.depth) = sub.depth + 1); --safety -- 1. The depth never changes by more than one unit per step.--true
  LTLSPEC
  G(sub.depth >= 0 & sub.depth <= 10);--safety -- 2. The depth always stays within interval 0..10.--true
  LTLSPEC
  G(F next(sub.depth) = 0);--liveness -- 3. The submarine always has the capability to get back to the surface.--Fairness property?--true
  CTLSPEC
  AG(!emergency -> AF(emergency | target_reached));--liveness -- 4. The submarine has the capability to reach target_depth , unless there is an emergency.--true
  LTLSPEC
  G((emergency | sub.hatch = open) -> next(sub.direction) != down);--safety -- 5. In an emergency or when the hatch is open, the submarine does not go down.--false
  /--
  LTLSPEC
  G(sub.hatch = open -> !(next(sub.depth) = sub.depth - 1));--safety -- 5. In an emergency or when the hatch is open, the submarine does not go down.
  LTLSPEC
  G(emergency U sub.depth = 0);--safety -- 6. An emergency can only be resolved by resurfacing (so emergency cannot go back to false once set unless depth=0.
  LTLSPEC
  G(sub.depth > 0 -> sub.hatch = closed);--safety -- 7. The hatch is always closed when submerged, i.e., depth>0.
  LTLSPEC
  G !(sub.lock = locked -> sub.hatch = open);--safety -- 8. The hatch can only open when it is unlocked.
  LTLSPEC  
  G(sub.submerged -> sub.lock = locked);--safety -- 9. The hatch lock must be locked whenever depth>0.
  LTLSPEC
  G!(sub.hatch = open -> sub.lock = locked);-- safety --10. The lock can only be in state locked when the hatch is closed.
  --/


/--
Example error trace for a mutated model 
before:
next (depth) := case -- next depth depending on direction
	direction = flat : depth; -- if the direction is flat, the depth remains the same
	direction = up : depth - 1; -- if the direction is up, the depth is reduced by one
	direction = down : depth + 1; -- if the direction is down, the depth is increasing by one
	TRUE: depth;
	esac;
--error message
file submarine_mandatory.smv: line 36: cannot assign value 11 to variable sub.depth

the direction should be flat at 10 and the depth should remain to not reach number 11 as a value. That is why we added extra conditions for depth before reducing/ increasing it.
--
after:
  next (depth) := case -- next depth depending on direction
	direction = flat : depth; -- if the direction is flat, the depth remains the same
	direction = up & depth > 0: depth - 1; -- if the direction is up, the depth is reduced by one
	direction = down & depth < 10: depth + 1; -- if the direction is down, the depth is increasing by one
	TRUE: depth;
    -- TODO: define next state
	esac;
--/

/--
Example error trace for a mutated property
-- specification  G (emergency -> !(sub.direction = down))  is false
-- as demonstrated by the following execution sequence
Trace Description: LTL Counterexample
Trace Type: Counterexample
  -> State: 2.1 <-
    sub.hatch = closed
    sub.lock = locked
    sub.direction = flat
    sub.depth = 7
    target_reached = FALSE
    emergency = TRUE
    target_depth = 8
    sub.submerged = TRUE
  -> State: 2.2 <-
    sub.direction = up
  -> State: 2.3 <-
    sub.depth = 6
  -> State: 2.4 <-
    sub.depth = 5
  -> State: 2.5 <-
    sub.depth = 4
  -> State: 2.6 <-
    sub.depth = 3
  -> State: 2.7 <-
    sub.depth = 2
  -> State: 2.8 <-
    sub.depth = 1
  -> State: 2.9 <-
    sub.direction = flat
    sub.depth = 0
    sub.submerged = FALSE
  -> State: 2.10 <-
    sub.lock = unlocked
    sub.direction = down
  -- Loop starts here
  -> State: 2.11 <-
    sub.lock = locked
    sub.direction = flat
    sub.depth = 1
    sub.submerged = TRUE
  -> State: 2.12 <-
    sub.direction = up
  -> State: 2.13 <-
    sub.direction = flat
    sub.depth = 0
    sub.submerged = FALSE
  -> State: 2.14 <-
    sub.lock = unlocked
    sub.direction = down
    emergency = FALSE
  -> State: 2.15 <-
    sub.lock = locked
    sub.direction = flat
    sub.depth = 1
    emergency = TRUE
    sub.submerged = TRUE
	
	solution:
	-- specification  G (emergency -> next(sub.direction) != down)  is true
	not the current state needs to be that it should go down, but the next upcoming state. Otherwise the submarine is able to go down during an emergency.
next (sub.direction) := case
	 target_reached : flat;
	 !target_reached & !emergency & target_depth > sub.depth : down;
	 emergency & sub.depth > 0: up;
	 emergency & sub.depth = 0: flat;
	 !emergency & sub.depth = 0 & sub.hatch = closed: { flat, down };
	 sub.depth = 0: {flat, down};--moreover we had to change the order of case elements here so these elements about sub.depth have to be at the end so they are only regarded if the ones before are not fulfilled
	 sub.depth = 10: {flat, up};
    TRUE: { up, flat, down };
  esac;
--/
/--
simulate -i -k 5 simulate 5 states and document the outcome
--/

/--
missing feature in the model
--/

/--
property for missing feature
--/









